import {
  ASSEMBLING,
  BUYING_ROBOT,
  MINING_BAR,
  MINING_FOO,
  MOVING,
} from "../actions";
import { FailureGenerator, SuccessGenerator } from "../RandomGenerator";
import { Location, Robot } from "../Robot";
import { Store } from "../Store";

let robot: Robot;
let store: Store;

beforeEach(() => {
  store = new Store();
  robot = new Robot(store);
});

describe("Robot actions", () => {
  describe("move", () => {
    it("moves to the next location  after the required time", () => {
      let currentTime = 0;
      robot.setNextLocation(Location.FOO_MINE);
      robot.startMoving(currentTime);
      currentTime += MOVING.totalDuration - 1;
      robot.tick(currentTime);
      expect(robot.getLocation()).toEqual(Location.TRANSITION);
      currentTime += 1;
      robot.tick(currentTime);
      expect(robot.getLocation()).toEqual(Location.FOO_MINE);
    });

    it(`throws an error when trying to start moving:
        - without next location defined
        - while the robot is not available
        - while the robot is asked to keep its location`, () => {
      function moveNoLocation() {
        robot.startMoving(0);
      }
      expect(moveNoLocation).toThrowError(
        "The robot can't start moving without next location specified."
      );

      robot.setNextLocation(Location.FOO_MINE);
      robot.startMoving(0);
      robot.tick(100);
      robot.setNextLocation(Location.ASSEMBLING_FACTORY);
      function moveNotAvailable() {
        robot.startMoving(0);
      }
      expect(moveNotAvailable).toThrowError("The robot is not available yet");

      robot = new Robot(new Store());
      robot.setNextLocation(Location.FOO_MINE);
      robot.setKeepLocation(true);
      function moveKeepLocation() {
        robot.startMoving(0);
      }
      expect(moveKeepLocation).toThrowError(
        "The robot can't start moving while it has been asked to keep its location."
      );
    });
  });

  describe("mine", () => {
    it("mines after the required time when being on a mine location", () => {
      robot = new Robot(store, {
        initialLocation: Location.FOO_MINE,
      });
      var currentTime = 0;
      robot.startMining(currentTime);
      currentTime += MINING_FOO.totalDuration - 1;
      robot.tick(currentTime);
      expect(store.getFoosAmount()).toEqual(0);
      currentTime += 1;
      robot.tick(currentTime);
      expect(store.getFoosAmount()).toEqual(1);

      store = new Store();
      robot = new Robot(store, {
        initialLocation: Location.BAR_MINE,
        randomGenerator: new SuccessGenerator(),
      });
      currentTime = 0;
      robot.startMining(currentTime);
      currentTime += MINING_BAR.randomBetween[1] - 1;
      robot.tick(currentTime);
      expect(store.getBarsAmount()).toEqual(0);
      currentTime += 1;
      robot.tick(currentTime);
      expect(store.getBarsAmount()).toEqual(1);
    });

    it(`mines bars after a random value generated by the random 
    generator`, () => {
      robot = new Robot(store, {
        randomGenerator: new FailureGenerator(),
        initialLocation: Location.BAR_MINE,
      });
      let currentTime = 0;
      robot.startMining(currentTime);
      currentTime += MINING_BAR.randomBetween[0] - 1;
      robot.tick(currentTime);
      expect(store.getBarsAmount()).toEqual(0);
      currentTime += 1;
      robot.tick(currentTime);
      expect(store.getBarsAmount()).toEqual(1);
    });

    it(`throws an error when trying to start mining:
        - somewhere else than a in a mine
        - while the robot is not available`, () => {
      robot = new Robot(store, {
        initialLocation: Location.ASSEMBLING_FACTORY,
      });
      function mineAndThrow() {
        robot.startMining(0);
      }
      expect(mineAndThrow).toThrowError("The robot has to be in a mine");

      robot.setNextLocation(Location.FOO_MINE);
      robot.startMoving(0);
      robot.tick(100);
      function mineNotAvailable() {
        robot.startMining(0);
      }
      expect(mineNotAvailable).toThrowError("The robot is not available yet");
    });
  });

  describe("assemble", () => {
    it(`creates a foobar after the required time, when on assembling factory,
    with enough foos and bars, in case of success.`, () => {
      store.setFoosAmount(1);
      store.setBarsAmount(1);
      robot = new Robot(store, {
        randomGenerator: new SuccessGenerator(),
        initialLocation: Location.ASSEMBLING_FACTORY,
      });
      let currentTime = 0;
      robot.startAssembling(currentTime);
      currentTime += ASSEMBLING.totalDuration - 1;
      robot.tick(currentTime);
      expect(store.getFoobarsAmount()).toEqual(0);
      expect(store.getBarsAmount()).toEqual(0);
      expect(store.getFoosAmount()).toEqual(0);
      currentTime += 1;
      robot.tick(currentTime);
      expect(store.getFoobarsAmount()).toEqual(1);
      expect(store.getBarsAmount()).toEqual(0);
      expect(store.getFoosAmount()).toEqual(0);
    });

    it(`looses the foo and keeps the bar in case of failure`, () => {
      store.setFoosAmount(1);
      store.setBarsAmount(1);
      robot = new Robot(store, {
        randomGenerator: new FailureGenerator(),
        initialLocation: Location.ASSEMBLING_FACTORY,
      });
      let currentTime = 0;
      robot.startAssembling(currentTime);
      currentTime += ASSEMBLING.totalDuration;
      robot.tick(currentTime);
      expect(store.getFoobarsAmount()).toEqual(0);
      expect(store.getBarsAmount()).toEqual(1);
      expect(store.getFoosAmount()).toEqual(0);
    });

    it(`throws an error:
       - when trying to assemble somewhere else than in the assemble factory
       - without enough foos and bars
       - while the robot is not available`, () => {
      store.setFoosAmount(1);
      store.setBarsAmount(1);
      robot = new Robot(store, {
        randomGenerator: new SuccessGenerator(),
      });
      function assembleWrongLocation() {
        robot.startAssembling(0);
      }
      expect(assembleWrongLocation).toThrowError(
        "The robot has to be in the assembling factory"
      );

      robot = new Robot(store, {
        randomGenerator: new SuccessGenerator(),
        initialLocation: Location.ASSEMBLING_FACTORY,
      });
      store.setFoosAmount(0);
      function assembleNotEnoughFoo() {
        robot.startAssembling(0);
      }
      expect(assembleNotEnoughFoo).toThrowError(
        "To create a foobar the robot needs one foo and one bar"
      );

      robot.setNextLocation(Location.FOO_MINE);
      robot.startMoving(0);
      robot.tick(100);
      function assembleNotAvailable() {
        robot.startAssembling(0);
      }
      expect(assembleNotAvailable).toThrowError(
        "The robot is not available yet"
      );
    });
  });

  describe("buy a robot", () => {
    it(`buys a new robot when on shop and with enough 
    foos and foobars`, () => {
      store = new Store();
      store.setFoosAmount(6);
      store.setFoobarsAmount(3);
      robot = new Robot(store);
      let currentTime = 0;
      robot.startBuyingRobot(currentTime);
      currentTime += BUYING_ROBOT.totalDuration;
      robot.tick(currentTime);
      expect(store.getFoobarsAmount()).toEqual(0);
      expect(store.getFoosAmount()).toEqual(0);
      expect(store.getRobots()).toHaveLength(2);
    });

    it(`throws an error:
        - when trying to buy a tobot somewhere else than in the shop
        - without enough foos and foobars
        - while the robot is not available`, () => {
      store.setFoosAmount(6);
      store.setFoobarsAmount(3);
      robot = new Robot(store, {
        initialLocation: Location.ASSEMBLING_FACTORY,
      });
      function buyBadLocation() {
        robot.startBuyingRobot(0);
      }
      expect(buyBadLocation).toThrowError("The robot has to be in the shop");

      robot = new Robot(store);
      function buyNotEnoughFoo() {
        robot.startBuyingRobot(0);
      }
      store.setFoosAmount(2);
      expect(buyNotEnoughFoo).toThrowError(
        "To buy a new robot, the robot needs 6 foos and 3 foobars"
      );

      robot.setNextLocation(Location.FOO_MINE);
      robot.startMoving(0);
      robot.tick(100);
      function buyNotAvailable() {
        robot.startBuyingRobot(0);
      }
      expect(buyNotAvailable).toThrowError("The robot is not available yet");
    });
  });
});
