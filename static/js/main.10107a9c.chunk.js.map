{"version":3,"sources":["domain/actions.ts","reportWebVitals.ts","domain/DateTime.ts","domain/Observable.ts","domain/Robot.ts","domain/RandomGenerator.ts","domain/Store.ts","domain/Strategy.ts","domain/Game.ts","ui/contexts/game.ts","ui/hooks/useGameState.ts","utils.ts","ui/hooks/useRobotsAmountByLocation.ts","ui/RobotsLocations.tsx","ui/Statistics.tsx","ui/Foobartory.tsx","index.tsx"],"names":["ActionType","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","RealDateTime","Date","now","ObservedRobot","MOVING","actionType","totalDuration","MINING_FOO","MINING_BAR","randomBetween","ASSEMBLING","BUYING_ROBOT","WAITING","ASSEMBLING_NEEDED_RESSOURCES","foos","bars","foobars","BUYING_ROBOT_NEEDED_RESSOURCES","Observable","callbacks","this","Map","information","callback","get","push","value","forEach","ObservedAmount","ObservableRobot","set","ROBOT_LOCATION","Location","ObservableStore","FOOS_AMOUNT","BARS_AMOUNT","FOOBARS_AMOUNT","ROBOTS_AMOUNT","RealRandomGenerator","percentage","Error","Math","random","min","max","values","_checkWeights","weightsSum","Array","from","reduce","a","b","chosenValue","entries","next","sum","key","weights","some","x","every","Robot","store","options","location","action","randomGenerator","nextLocation","actionStartTime","keepLocation","observable","getRobotsObservable","addRobot","SHOP","setLocation","initialLocation","currentTime","actionTotalDuration","actionCurrentDuration","randomBetweenTwoValues","_endAction","_moveTo","_mineFoo","_mineBar","_assemble","_buyRobot","setFoosAmount","getFoosAmount","setBarsAmount","getBarsAmount","randomPercentageSuccess","setFoobarsAmount","getFoobarsAmount","checkAvailable","_checkLocationSpecified","_checkNotKeepingLocation","TRANSITION","FOO_MINE","BAR_MINE","_checkLocation","ASSEMBLING_FACTORY","_checkRessources","getNextLocation","getKeepLocation","errorMessageBeginning","neededRessources","isAvailable","_canDoAction","subscribe","locations","getRobots","robot","getLocation","trigger","Store","foosAmount","barsAmount","fooBarsAmount","robots","robotsObservable","amount","length","BasicStrategy","automaticMovementProbability","automaticLocationProbabilities","weight","probability","tick","startMoving","_handleAutomaticActions","_doAutomaticMove","_doAutomaticOtherActions","possibleLocations","delete","chosenLocation","chooseValue","setNextLocation","exception","message","includes","startMining","canAssemble","startAssembling","canBuyRobot","startBuyingRobot","Game","strategy","dateTime","started","requestId","nextFrame","getCurrentTime","actOnOneFrame","requestAnimationFrame","cancelAnimationFrame","id","subscribeToRobots","GameContext","React","createContext","useStoreState","game","initialValue","observed","useState","storeState","setStoreState","useEffect","subscribeToAmount","IncrementableMap","has","useRobotsAmountByLocation","robotsLocation","robotState","setRobotState","useRobotState","useMemo","increment","RobotsLocations","robotsAmountByLocation","useContext","Statistics","foobarsAmount","robotsAmount","Foobartory","useRef","current","start","getStrategy","setLocationWeight","setAutomaticMovementProbability","Provider","role","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.10107a9c.chunk.js","sourcesContent":["enum ActionType {\n  MOVING = \"moving\",\n  MINING_FOO = \"mining foo\",\n  MINING_BAR = \"mining bar\",\n  ASSEMBLING = \"assembling\",\n  BUYING_ROBOT = \"buying robot\",\n  WAITING = \"waiting\",\n}\n\ninterface ActionBase {\n  actionType: ActionType;\n}\ninterface ActionWithDuration extends ActionBase {\n  totalDuration: number;\n}\ninterface ActionWithRandom extends ActionBase {\n  randomBetween: [number, number];\n}\n\ntype Action = ActionWithDuration | ActionWithRandom;\n\nconst MOVING: Action = {\n  actionType: ActionType.MOVING,\n  totalDuration: 5000,\n};\n\nconst MINING_FOO: Action = {\n  actionType: ActionType.MINING_FOO,\n  totalDuration: 1000,\n};\n\nconst MINING_BAR: Action = {\n  actionType: ActionType.MINING_BAR,\n  randomBetween: [500, 2000],\n};\n\nconst ASSEMBLING: Action = {\n  actionType: ActionType.ASSEMBLING,\n  totalDuration: 2000,\n};\n\nconst BUYING_ROBOT: Action = {\n  actionType: ActionType.BUYING_ROBOT,\n  totalDuration: 0,\n};\n\nconst WAITING: Action = {\n  actionType: ActionType.WAITING,\n  totalDuration: 0,\n};\n\ntype NeededRessources = {\n  foos: number;\n  bars: number;\n  foobars: number;\n};\n\nconst ASSEMBLING_NEEDED_RESSOURCES: NeededRessources = {\n  foos: 1,\n  bars: 1,\n  foobars: 0,\n};\n\nconst BUYING_ROBOT_NEEDED_RESSOURCES: NeededRessources = {\n  foos: 6,\n  bars: 0,\n  foobars: 3,\n};\n\nexport {\n  MOVING,\n  MINING_BAR,\n  MINING_FOO,\n  ASSEMBLING,\n  BUYING_ROBOT,\n  WAITING,\n  ASSEMBLING_NEEDED_RESSOURCES,\n  BUYING_ROBOT_NEEDED_RESSOURCES,\n};\nexport type { Action, NeededRessources };\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","interface DateTime {\n  getCurrentTime(): number;\n}\n\nclass FakeDateTime implements DateTime {\n  constructor(private time: number = 0) {}\n  advance(miliseconds: number) {\n    this.time += miliseconds;\n  }\n\n  getCurrentTime(): number {\n    return this.time;\n  }\n}\n\nclass RealDateTime implements DateTime {\n  getCurrentTime(): number {\n    return Date.now();\n  }\n}\n\nexport { FakeDateTime, RealDateTime };\nexport type { DateTime };\n","class Observable<Observed> {\n  protected callbacks: Map<Observed, Function[]>;\n\n  constructor() {\n    this.callbacks = new Map();\n  }\n\n  subscribe(information: Observed, callback: Function) {\n    this.callbacks.get(information)?.push(callback);\n  }\n\n  trigger<T>(information: Observed, value: T) {\n    const callbacks = this.callbacks.get(information);\n    if (callbacks) {\n      callbacks.forEach(function callObservers(callback) {\n        callback(value);\n      });\n    }\n  }\n}\n\nenum ObservedRobot {\n  ROBOT_LOCATION,\n}\n\nclass ObservableRobot extends Observable<ObservedRobot> {\n  constructor() {\n    super();\n    this.callbacks.set(ObservedRobot.ROBOT_LOCATION, []);\n  }\n}\n\nenum ObservedAmount {\n  FOOS_AMOUNT,\n  BARS_AMOUNT,\n  FOOBARS_AMOUNT,\n  ROBOTS_AMOUNT,\n}\n\nclass ObservableStore extends Observable<ObservedAmount> {\n  constructor() {\n    super();\n    this.callbacks.set(ObservedAmount.FOOS_AMOUNT, []);\n    this.callbacks.set(ObservedAmount.BARS_AMOUNT, []);\n    this.callbacks.set(ObservedAmount.FOOBARS_AMOUNT, []);\n    this.callbacks.set(ObservedAmount.ROBOTS_AMOUNT, []);\n  }\n}\n\nexport {\n  Observable,\n  ObservableRobot,\n  ObservedRobot,\n  ObservableStore,\n  ObservedAmount,\n};\n","import {\n  Action,\n  ASSEMBLING,\n  ASSEMBLING_NEEDED_RESSOURCES,\n  BUYING_ROBOT,\n  BUYING_ROBOT_NEEDED_RESSOURCES,\n  MINING_BAR,\n  MINING_FOO,\n  MOVING,\n  NeededRessources,\n  WAITING,\n} from \"./actions\";\nimport { ObservableRobot, ObservedRobot } from \"./Observable\";\nimport { RandomGenerator, RealRandomGenerator } from \"./RandomGenerator\";\nimport { Store } from \"./Store\";\n\nenum Location {\n  FOO_MINE = \"foo mine\",\n  BAR_MINE = \"bar mine\",\n  ASSEMBLING_FACTORY = \"assembling factory\",\n  SHOP = \"shop\",\n  TRANSITION = \"transition\",\n}\n\ntype RobotOptions = {\n  randomGenerator?: RandomGenerator;\n  initialLocation?: Location;\n};\n\n/**\n * The robot is the main character. It does nothing by itself except\n * finishing the execution of the actions it was asked to start.\n * To make it finish its actions, it needs to get regularly its method\n * tick() called with the current time.\n */\nclass Robot {\n  private location: Location;\n  private action: Action;\n  private randomGenerator: RandomGenerator;\n  private nextLocation: Location | null;\n  private actionStartTime: number | null;\n  private keepLocation;\n  private observable: ObservableRobot;\n\n  constructor(private store: Store, options?: RobotOptions) {\n    this.nextLocation = null;\n    this.keepLocation = false;\n    this.action = WAITING;\n    this.actionStartTime = null;\n    this.observable = store.getRobotsObservable();\n    this.store.addRobot(this);\n    this.location = Location.SHOP;\n    this.setLocation(\n      options?.initialLocation ? options.initialLocation : Location.SHOP\n    );\n    this.randomGenerator = options?.randomGenerator\n      ? options?.randomGenerator\n      : new RealRandomGenerator();\n  }\n\n  /**\n   * If the current action duration has been reached, ends the\n   * action to make the robot available again, and executes its\n   * consequences.\n   * @param currentTime the current time in miliseconds.\n   */\n  tick(currentTime: number) {\n    if (this.actionStartTime !== null) {\n      const actionCurrentDuration = currentTime - this.actionStartTime;\n      let actionTotalDuration: number;\n      if (\"randomBetween\" in this.action) {\n        actionTotalDuration = this.randomGenerator.randomBetweenTwoValues(\n          ...this.action.randomBetween\n        );\n      } else {\n        actionTotalDuration = this.action.totalDuration;\n      }\n      if (actionCurrentDuration >= actionTotalDuration) {\n        this._endAction();\n      }\n    }\n  }\n\n  _endAction() {\n    switch (this.action.actionType) {\n      case MOVING.actionType: {\n        if (this.nextLocation) {\n          this._moveTo(this.nextLocation);\n        } else {\n          throw new Error(\n            \"The robot can't end its move without a location specified.\"\n          );\n        }\n        break;\n      }\n      case MINING_FOO.actionType: {\n        this._mineFoo();\n        break;\n      }\n      case MINING_BAR.actionType: {\n        this._mineBar();\n        break;\n      }\n      case ASSEMBLING.actionType: {\n        this._assemble();\n        break;\n      }\n      case BUYING_ROBOT.actionType: {\n        this._buyRobot();\n        break;\n      }\n      default: {\n        throw new Error(\n          `There is a start time defined for an action, but the action of the robot is incorrect (${this.action.actionType}).`\n        );\n      }\n    }\n    this.action = WAITING;\n    this.actionStartTime = null;\n  }\n\n  private _moveTo(location: Location) {\n    this.setLocation(location);\n    this.nextLocation = null;\n  }\n\n  private _mineFoo() {\n    this.store.setFoosAmount(this.store.getFoosAmount() + 1);\n  }\n\n  private _mineBar() {\n    this.store.setBarsAmount(this.store.getBarsAmount() + 1);\n  }\n\n  private _assemble() {\n    const isAssemblingSuccessful =\n      this.randomGenerator.randomPercentageSuccess(60);\n    if (isAssemblingSuccessful) {\n      this.store.setFoobarsAmount(this.store.getFoobarsAmount() + 1);\n    } else {\n      this.store.setBarsAmount(this.store.getBarsAmount() + 1);\n    }\n  }\n\n  private _buyRobot() {\n    new Robot(this.store);\n  }\n\n  startMoving(currentTime: number) {\n    this.checkAvailable();\n    this._checkLocationSpecified();\n    this._checkNotKeepingLocation();\n    this.setLocation(Location.TRANSITION);\n    this.action = MOVING;\n    this.actionStartTime = currentTime;\n  }\n\n  startMining(currentTime: number) {\n    this.checkAvailable();\n    if (this.location === Location.FOO_MINE) {\n      this.action = MINING_FOO;\n    } else if (this.location === Location.BAR_MINE) {\n      this.action = MINING_BAR;\n    } else {\n      throw new Error(\n        `The robot has to be in a mine to mine, here it is in ${this.location}.`\n      );\n    }\n    this.actionStartTime = currentTime;\n  }\n\n  startAssembling(currentTime: number) {\n    this.checkAvailable();\n    this._checkLocation(Location.ASSEMBLING_FACTORY);\n    this._checkRessources(\n      \"To create a foobar the robot needs one foo and one bar\",\n      ASSEMBLING_NEEDED_RESSOURCES\n    );\n\n    this.action = ASSEMBLING;\n    this.actionStartTime = currentTime;\n    this.store.setBarsAmount(this.store.getBarsAmount() - 1);\n    this.store.setFoosAmount(this.store.getFoosAmount() - 1);\n  }\n\n  startBuyingRobot(currentTime: number) {\n    this.checkAvailable();\n    this._checkLocation(Location.SHOP);\n    this._checkRessources(\n      \"To buy a new robot, the robot needs 6 foos and 3 foobars\",\n      BUYING_ROBOT_NEEDED_RESSOURCES\n    );\n    this.action = BUYING_ROBOT;\n    this.actionStartTime = currentTime;\n    this.store.setFoobarsAmount(this.store.getFoobarsAmount() - 3);\n    this.store.setFoosAmount(this.store.getFoosAmount() - 6);\n  }\n\n  private _checkLocation(location: Location) {\n    if (location !== this.location) {\n      throw new Error(\n        `The robot has to be in the ${location}, here it is in ${this.location}.`\n      );\n    }\n  }\n\n  private _checkLocationSpecified() {\n    if (!this.getNextLocation()) {\n      throw new Error(\n        \"The robot can't start moving without next location specified.\"\n      );\n    }\n  }\n\n  private _checkNotKeepingLocation() {\n    if (this.getKeepLocation()) {\n      throw new Error(\n        \"The robot can't start moving while it has been asked to keep its location.\"\n      );\n    }\n  }\n\n  private _checkRessources(\n    errorMessageBeginning: string,\n    neededRessources: NeededRessources\n  ) {\n    const enoughRessources =\n      this.store.getFoobarsAmount() >= neededRessources.foobars &&\n      this.store.getFoosAmount() >= neededRessources.foos &&\n      this.store.getBarsAmount() >= neededRessources.bars;\n    if (!enoughRessources) {\n      throw new Error(\n        `${errorMessageBeginning}.\n        There are only ${this.store.getFoosAmount()} foos, ${this.store.getBarsAmount()} bars and ${this.store.getFoobarsAmount()} foobars.`\n      );\n    }\n  }\n\n  private checkAvailable() {\n    if (!this.isAvailable()) {\n      throw new Error(`The robot is not available yet`);\n    }\n  }\n\n  canAssemble(): boolean {\n    return this._canDoAction(ASSEMBLING_NEEDED_RESSOURCES);\n  }\n\n  canBuyRobot(): boolean {\n    return this._canDoAction(BUYING_ROBOT_NEEDED_RESSOURCES);\n  }\n\n  private _canDoAction(neededRessources: NeededRessources) {\n    try {\n      this._checkRessources(\"\", neededRessources);\n    } catch {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * State the availability of the robot. A new action can't be started\n   * without the robot being available.\n   */\n  isAvailable(): boolean {\n    return this.action === WAITING;\n  }\n\n  subscribe(information: ObservedRobot, callback: Function) {\n    this.observable.subscribe(information, callback);\n  }\n\n  /**\n   * Set the next location where starting to move will lead.\n   * A movement can't be started without that location set.\n   */\n  setNextLocation(location: Location) {\n    this.nextLocation = location;\n  }\n\n  getNextLocation(): Location | null {\n    return this.nextLocation;\n  }\n\n  getLocation() {\n    return this.location;\n  }\n\n  setLocation(location: Location) {\n    this.location = location;\n    const locations: Location[] = [];\n    this.store.getRobots().forEach((robot) => {\n      locations.push(robot.getLocation());\n    });\n    this.observable.trigger(ObservedRobot.ROBOT_LOCATION, locations);\n  }\n\n  getAction() {\n    return this.action;\n  }\n\n  setKeepLocation(keepLocation: boolean) {\n    this.keepLocation = keepLocation;\n  }\n\n  getKeepLocation() {\n    return this.keepLocation;\n  }\n}\n\nexport { Robot, Location, ObservedRobot };\n","type WeightedValues<T> = Map<T, number>;\n\ninterface RandomGenerator {\n  /**\n   * Compute a boolean according to a given percentage.\n   * @param percentage the percentage of chances to be true\n   *     (value between 0 and 100).\n   */\n  randomPercentageSuccess(percentage: number): boolean;\n\n  /**\n   * Compute a value between two given values\n   */\n  randomBetweenTwoValues(min: number, max: number): number;\n\n  /**\n   * Choose randomly one of the provided values, according to\n   * the given weights for each value.\n   * If the weight is 0, the value will never be chosen, if it\n   * is a positive number, the bigger it will be compared to\n   * the weight of the other values, the more chances it will\n   * have to be chosen.\n   * @param values the chosen value.\n   */\n  chooseValue<T>(values: WeightedValues<T>): T;\n}\n\nclass RealRandomGenerator implements RandomGenerator {\n  randomPercentageSuccess(percentage: number): boolean {\n    if (percentage < 0 || percentage > 100) {\n      throw new Error(\n        `The given percentage has to be between 0 and 100, not ${percentage}.`\n      );\n    }\n    const random = Math.random() * 100;\n    if (random < percentage) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  randomBetweenTwoValues(min: number, max: number): number {\n    const value = min + Math.random() * (max - min);\n    return value;\n  }\n\n  chooseValue<T>(values: WeightedValues<T>): T {\n    this._checkWeights(values);\n    const weightsSum = Array.from(values.values()).reduce((a, b) => a + b);\n    const random = Math.random() * weightsSum;\n    let chosenValue: T = values.entries().next().value;\n    let sum = 0;\n    for (let [key, value] of values) {\n      sum += value;\n      if (random <= sum) {\n        chosenValue = key;\n        break;\n      }\n    }\n    return chosenValue;\n  }\n\n  private _checkWeights<T>(values: WeightedValues<T>) {\n    const weights = Array.from(values.values());\n    const negativeWeight = weights.some((x) => x < 0);\n    if (negativeWeight) {\n      const entries = Array.from(values.entries());\n      throw new Error(`Negative weights are not allowed. Entries: ${entries}`);\n    }\n    const onlyZeroWeights = weights.every((x) => x === 0);\n    if (onlyZeroWeights) {\n      const entries = Array.from(values.entries());\n      throw new Error(\n        `At least one of the weights has to be > 0. Entries: ${entries}`\n      );\n    }\n  }\n}\n\n/**\n * Fake generator always returning true or the maximal value,\n * used for tests.\n */\nclass SuccessGenerator implements RandomGenerator {\n  randomPercentageSuccess(percentage: number): boolean {\n    return true;\n  }\n\n  randomBetweenTwoValues(min: number, max: number): number {\n    return max;\n  }\n\n  chooseValue<T>(values: WeightedValues<T>): T {\n    const biggestPair = [...values.entries()].reduce((v1, v2) =>\n      v1[1] > v2[1] ? v1 : v2\n    );\n    return biggestPair[0];\n  }\n}\n\n/**\n * Fake generator always returning false or the minimal value,\n * used for tests.\n */\nclass FailureGenerator implements RandomGenerator {\n  randomPercentageSuccess(percentage: number): boolean {\n    return false;\n  }\n\n  randomBetweenTwoValues(min: number, max: number): number {\n    return min;\n  }\n\n  chooseValue<T>(values: WeightedValues<T>): T {\n    const smallestPair = [...values.entries()].reduce((v1, v2) =>\n      v1[1] < v2[1] ? v1 : v2\n    );\n    return smallestPair[0];\n  }\n}\n\nexport { RealRandomGenerator, SuccessGenerator, FailureGenerator };\nexport type { RandomGenerator, WeightedValues };\n","import {\n  ObservableRobot,\n  ObservableStore,\n  ObservedAmount,\n  ObservedRobot,\n} from \"./Observable\";\nimport { Robot } from \"./Robot\";\n\nclass Store {\n  private foosAmount: number;\n  private barsAmount: number;\n  private fooBarsAmount: number;\n  private robots: Robot[];\n  private observable: ObservableStore;\n  private robotsObservable: ObservableRobot;\n\n  constructor() {\n    this.observable = new ObservableStore();\n    this.robotsObservable = new ObservableRobot();\n    this.foosAmount = 0;\n    this.barsAmount = 0;\n    this.fooBarsAmount = 0;\n    this.robots = [];\n  }\n\n  subscribe(information: ObservedAmount, callback: Function) {\n    this.observable.subscribe(information, callback);\n  }\n\n  subscribeToRobots(information: ObservedRobot, callback: Function) {\n    this.robotsObservable.subscribe(information, callback);\n  }\n\n  setFoosAmount(amount: number) {\n    this.foosAmount = amount;\n    this.observable.trigger(ObservedAmount.FOOS_AMOUNT, this.foosAmount);\n  }\n\n  getFoosAmount() {\n    return this.foosAmount;\n  }\n\n  setBarsAmount(amount: number) {\n    this.barsAmount = amount;\n    this.observable.trigger(ObservedAmount.BARS_AMOUNT, this.barsAmount);\n  }\n\n  getBarsAmount() {\n    return this.barsAmount;\n  }\n\n  setFoobarsAmount(amount: number) {\n    this.fooBarsAmount = amount;\n    this.observable.trigger(ObservedAmount.FOOBARS_AMOUNT, this.fooBarsAmount);\n  }\n\n  getFoobarsAmount() {\n    return this.fooBarsAmount;\n  }\n\n  addRobot(robot: Robot) {\n    this.robots.push(robot);\n    this.observable.trigger(ObservedAmount.ROBOTS_AMOUNT, this.robots.length);\n  }\n\n  getRobots() {\n    return this.robots;\n  }\n\n  getRobotsObservable() {\n    return this.robotsObservable;\n  }\n}\n\nexport { Store, ObservedAmount, ObservedRobot };\n","import { RandomGenerator, RealRandomGenerator } from \"./RandomGenerator\";\nimport { Location, Robot } from \"./Robot\";\nimport { Store } from \"./Store\";\ninterface Strategy {\n  actOnOneFrame(currentTime: number, store: Store): void;\n}\n\ntype BasicStrategyOptions = {\n  randomGenerator?: RandomGenerator;\n};\n\n/**\n * Implements a basic strategy:\n * With a manual part taking priority:\n * - does not move robots that have been manually told to keep location.\n * - moves robots to the indicated manual location if there is one.\n * And an automatic part:\n * - chooses randomly to make an available robot move to a random\n *   location, or instead do an action if possible.\n * - the random aspect of moving or not, and where to move can be\n *   influenced manually.\n */\nclass BasicStrategy implements Strategy {\n  private randomGenerator: RandomGenerator;\n  private automaticMovementProbability: number;\n  private automaticLocationProbabilities: Map<Location, number>;\n\n  constructor(options?: BasicStrategyOptions) {\n    this.randomGenerator = options?.randomGenerator\n      ? options.randomGenerator\n      : new RealRandomGenerator();\n    this.automaticMovementProbability = 50;\n    this.automaticLocationProbabilities = new Map([\n      [Location.FOO_MINE, 5],\n      [Location.BAR_MINE, 5],\n      [Location.ASSEMBLING_FACTORY, 5],\n      [Location.SHOP, 5],\n    ]);\n  }\n\n  /**\n   * This influences the probability to choose automatically one\n   * location instead of another.\n   * @param location the location to influence.\n   * @param weight the heigher the value relatively to others, the\n   *   more chances to go there.\n   */\n  setLocationWeight(location: Location, weight: number) {\n    if (weight < 0) {\n      throw new Error(\n        `The assigned weight ${weight} has to be greater than 0.`\n      );\n    }\n    this.automaticLocationProbabilities.set(location, weight);\n  }\n\n  /**\n   * The percentage of chances to get an automatic move each time.\n   */\n  setAutomaticMovementProbability(probability: number) {\n    this.automaticMovementProbability = probability;\n  }\n\n  /**\n   * Do some action on the content of the store, including robots.\n   * This function is called by the game several times per second.\n   * @param currentTime the time where the function is called.\n   */\n  actOnOneFrame(currentTime: number, store: Store) {\n    store.getRobots().forEach((robot) => {\n      robot.tick(currentTime);\n      if (robot.isAvailable()) {\n        const shouldDoManualMove =\n          robot.getNextLocation() && !robot.getKeepLocation();\n        if (shouldDoManualMove) {\n          robot.startMoving(currentTime);\n        } else {\n          this._handleAutomaticActions(robot, currentTime);\n        }\n      }\n    });\n  }\n\n  private _handleAutomaticActions(robot: Robot, currentTime: number) {\n    const shouldAutomaticallyMove =\n      this.randomGenerator.randomPercentageSuccess(\n        this.automaticMovementProbability\n      ) && !robot.getKeepLocation();\n    if (shouldAutomaticallyMove) {\n      this._doAutomaticMove(robot, currentTime);\n    } else {\n      this._doAutomaticOtherActions(robot, currentTime);\n    }\n  }\n\n  private _doAutomaticMove(robot: Robot, currentTime: number) {\n    const possibleLocations = new Map(this.automaticLocationProbabilities);\n    possibleLocations.delete(robot.getLocation());\n    try {\n      const chosenLocation =\n        this.randomGenerator.chooseValue(possibleLocations);\n      robot.setNextLocation(chosenLocation);\n      robot.startMoving(currentTime);\n    } catch (exception) {\n      if (\n        exception.message.includes(\"At least one of the weights has to be > 0\")\n      ) {\n        // in case of wrong weights (eg. (0, 0, 0)), we just don't move\n      } else {\n        throw exception;\n      }\n    }\n  }\n\n  private _doAutomaticOtherActions(robot: Robot, currentTime: number) {\n    switch (robot.getLocation()) {\n      case Location.FOO_MINE:\n      case Location.BAR_MINE:\n        robot.startMining(currentTime);\n        break;\n      case Location.ASSEMBLING_FACTORY:\n        if (robot.canAssemble()) {\n          robot.startAssembling(currentTime);\n        }\n        break;\n      case Location.SHOP:\n        if (robot.canBuyRobot()) {\n          robot.startBuyingRobot(currentTime);\n        }\n        break;\n      default:\n        throw new Error(\n          `An action has been requested while the robot was the wrong location (${robot.getLocation()}).`\n        );\n    }\n  }\n}\n\nexport { BasicStrategy };\nexport type { Strategy };\n","import { DateTime, RealDateTime } from \"./DateTime\";\nimport { ObservedAmount, ObservedRobot } from \"./Observable\";\nimport { Location, Robot } from \"./Robot\";\nimport { Store } from \"./Store\";\nimport { BasicStrategy, Strategy } from \"./Strategy\";\n\nconst MAX_ROBOTS_LENGTH = 20;\n\ntype GameOptions = {\n  dateTime?: DateTime;\n};\nclass Game {\n  public store: Store;\n  private dateTime: DateTime;\n  private strategy: Strategy;\n  private started: boolean;\n\n  constructor(strategy: Strategy, options?: GameOptions) {\n    this.store = new Store();\n    this.dateTime = options?.dateTime ? options.dateTime : new RealDateTime();\n    this.strategy = strategy ? strategy : new BasicStrategy();\n    new Robot(this.store);\n    new Robot(this.store);\n    this.started = false;\n  }\n\n  start() {\n    this.started = true;\n    let requestId = 0;\n    const nextFrame = () => {\n      const now = this.dateTime.getCurrentTime();\n      this.strategy.actOnOneFrame(now, this.store);\n      if (this.store.getRobots().length < MAX_ROBOTS_LENGTH) {\n        requestId = requestAnimationFrame(nextFrame);\n      } else {\n        cancelAnimationFrame(requestId);\n        this.started = false;\n      }\n    };\n    nextFrame();\n  }\n\n  setRobotNextLocation(id: number, location: Location) {\n    this.store.getRobots()[id].setNextLocation(location);\n  }\n\n  getRobotLocation(id: number): Location {\n    return this.store.getRobots()[id].getLocation();\n  }\n\n  getStrategy(): Strategy {\n    return this.strategy;\n  }\n\n  getStarted(): boolean {\n    return this.started;\n  }\n\n  subscribeToAmount(information: ObservedAmount, callback: Function) {\n    this.store.subscribe(information, callback);\n  }\n\n  subscribeToRobots(information: ObservedRobot, callback: Function) {\n    this.store.subscribeToRobots(information, callback);\n  }\n}\nexport { Game };\n","import React from \"react\";\nimport { BasicStrategy, Game } from \"../../domain\";\n\nconst GameContext = React.createContext<Game>(new Game(new BasicStrategy()));\n\nexport default GameContext;\n","import { useEffect, useState } from \"react\";\nimport { Game, ObservedAmount, ObservedRobot } from \"../../domain\";\n\n/**\n * These hooks create observer states, subscribing to the game\n * observable API.\n */\n\ninterface UseGameStateProps<T> {\n  game: Game;\n  initialValue: T;\n}\n\ninterface UseStoreStateProps<T> extends UseGameStateProps<T> {\n  observed: ObservedAmount;\n}\n\ninterface UseRobotStateProps<T> extends UseGameStateProps<T> {\n  observed: ObservedRobot;\n}\n\nfunction useStoreState<T>({\n  game,\n  initialValue,\n  observed,\n}: UseStoreStateProps<T>) {\n  const [storeState, setStoreState] = useState<T>(initialValue);\n  useEffect(\n    function observeStore() {\n      game.subscribeToAmount(observed, setStoreState);\n    },\n    [game, observed]\n  );\n  return storeState;\n}\n\nfunction useRobotState<T>({\n  game,\n  initialValue,\n  observed,\n}: UseRobotStateProps<T>) {\n  const [robotState, setRobotState] = useState<T>(initialValue);\n  useEffect(\n    function observeRobot() {\n      game.subscribeToRobots(observed, setRobotState);\n    },\n    [game, observed]\n  );\n  return robotState;\n}\n\nexport { useStoreState, useRobotState };\n","class IncrementableMap<T> extends Map<T, number> {\n  increment(key: T) {\n    this.has(key) && this.set(key, (this.get(key) as number) + 1);\n  }\n  decrement(key: T) {\n    this.has(key) && this.set(key, (this.get(key) as number) - 1);\n  }\n}\n\nexport { IncrementableMap };\n","import { useMemo } from \"react\";\nimport { Game, Location, ObservedRobot } from \"../../domain\";\nimport { IncrementableMap } from \"../../utils\";\nimport { useRobotState } from \"./useGameState\";\n\n/**\n * Build and return a Map associating locations with the number\n * of robots on that location.\n */\nfunction useRobotsAmountByLocation(game: Game) {\n  const robotsLocation = useRobotState<Location[]>({\n    game,\n    initialValue: [],\n    observed: ObservedRobot.ROBOT_LOCATION,\n  });\n\n  const robotsAmountByLocation = useMemo(() => {\n    let locations = new IncrementableMap<Location>([\n      [Location.FOO_MINE, 0],\n      [Location.BAR_MINE, 0],\n      [Location.ASSEMBLING_FACTORY, 0],\n      [Location.SHOP, 0],\n      [Location.TRANSITION, 0],\n    ]);\n    robotsLocation.forEach((location) => {\n      locations.increment(location);\n    });\n    return locations;\n  }, [robotsLocation]);\n\n  return robotsAmountByLocation;\n}\n\nexport { useRobotsAmountByLocation };\n","import { useContext } from \"react\";\nimport { Location } from \"../domain\";\nimport GameContext from \"./contexts/game\";\nimport { useRobotsAmountByLocation } from \"./hooks\";\n\n/**\n * Display a high level graphical view robots locations.\n */\nfunction RobotsLocations() {\n  const game = useContext(GameContext);\n  const robotsAmountByLocation = useRobotsAmountByLocation(game);\n  return (\n    <ul>\n      <li>Foo mine: {robotsAmountByLocation.get(Location.FOO_MINE)}</li>\n      <li>Bar mine: {robotsAmountByLocation.get(Location.BAR_MINE)}</li>\n      <li>\n        Assembling factory:{\" \"}\n        {robotsAmountByLocation.get(Location.ASSEMBLING_FACTORY)}\n      </li>\n      <li>Shop: {robotsAmountByLocation.get(Location.SHOP)}</li>\n      <li>Moving: {robotsAmountByLocation.get(Location.TRANSITION)}</li>\n    </ul>\n  );\n}\n\nexport default RobotsLocations;\n","import { useContext } from \"react\";\nimport { ObservedAmount } from \"../domain\";\nimport GameContext from \"./contexts/game\";\nimport { useStoreState } from \"./hooks\";\n\n/**\n * Display statistics on what is available in the game store.\n */\nfunction Statistics() {\n  const game = useContext(GameContext);\n  const foosAmount = useStoreState<number>({\n    game,\n    initialValue: game.store.getFoosAmount(),\n    observed: ObservedAmount.FOOS_AMOUNT,\n  });\n  const barsAmount = useStoreState<number>({\n    game,\n    initialValue: game.store.getBarsAmount(),\n    observed: ObservedAmount.BARS_AMOUNT,\n  });\n  const foobarsAmount = useStoreState<number>({\n    game,\n    initialValue: game.store.getFoobarsAmount(),\n    observed: ObservedAmount.FOOBARS_AMOUNT,\n  });\n  const robotsAmount = useStoreState<number>({\n    game,\n    initialValue: game.store.getRobots().length,\n    observed: ObservedAmount.ROBOTS_AMOUNT,\n  });\n  return (\n    <ul>\n      <li>\n        Foos: <span>{foosAmount}</span>\n      </li>\n      <li>\n        Bars: <span>{barsAmount}</span>\n      </li>\n      <li>\n        Foobars: <span>{foobarsAmount}</span>\n      </li>\n      <li>\n        Robots: <span>{robotsAmount}</span>\n      </li>\n    </ul>\n  );\n}\n\nexport default Statistics;\n","import React, { useEffect, useRef } from \"react\";\nimport { BasicStrategy, Game, Location } from \"../domain\";\nimport GameContext from \"./contexts/game\";\nimport RobotsLocations from \"./RobotsLocations\";\nimport Statistics from \"./Statistics\";\n\n/**\n * The main component holding the whole app.\n */\nfunction Foobartory() {\n  const game = useRef(new Game(new BasicStrategy()));\n  useEffect(() => {\n    game.current.start();\n    const strategy = game.current.getStrategy() as BasicStrategy;\n    strategy.setLocationWeight(Location.FOO_MINE, 10);\n    strategy.setLocationWeight(Location.BAR_MINE, 3);\n    strategy.setAutomaticMovementProbability(25);\n  }, []);\n  return (\n    <GameContext.Provider value={game.current}>\n      <main role=\"main\">\n        <Statistics />\n        <RobotsLocations />\n      </main>\n    </GameContext.Provider>\n  );\n}\n\nexport default Foobartory;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport Foobartory from \"./ui/Foobartory\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Foobartory />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}